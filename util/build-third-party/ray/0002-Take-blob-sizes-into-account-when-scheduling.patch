From 65a9448079937d79e5bb6a890d8f15e4ce094098 Mon Sep 17 00:00:00 2001
From: Nam Nguyen <nam@cern.ch>
Date: Fri, 24 Aug 2018 11:00:31 +0200
Subject: [PATCH 2/2] Take blob sizes into account when scheduling.

---
 src/global_scheduler/global_scheduler_algorithm.cc | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/src/global_scheduler/global_scheduler_algorithm.cc b/src/global_scheduler/global_scheduler_algorithm.cc
index 7ca1b86..b93ca1b 100644
--- a/src/global_scheduler/global_scheduler_algorithm.cc
+++ b/src/global_scheduler/global_scheduler_algorithm.cc
@@ -115,12 +115,14 @@ double calculate_cost_pending(const GlobalSchedulerState *state,
                               TaskSpec *task_spec) {
   /* Calculate how much data is already present on this machine. TODO(rkn): Note
    * that this information is not being used yet. Fix this. */
-  locally_available_data_size(state, scheduler->id, task_spec);
+  int64_t locally_available =
+      locally_available_data_size(state, scheduler->id, task_spec);
   /* TODO(rkn): This logic does not load balance properly when the different
    * machines have different sizes. Fix this. */
   double cost_pending = scheduler->num_recent_tasks_sent +
                         scheduler->info.task_queue_length -
                         scheduler->info.available_workers;
+  cost_pending -= locally_available;
   return cost_pending;
 }
 
@@ -235,6 +237,9 @@ bool handle_task_waiting_cost(GlobalSchedulerState *state,
 bool handle_task_waiting(GlobalSchedulerState *state,
                          GlobalSchedulerPolicyState *policy_state,
                          Task *task) {
+  if (state->local_schedulers.size() > 1) {
+    return handle_task_waiting_cost(state, policy_state, task);
+  }
   return handle_task_waiting_random(state, policy_state, task);
 }
 
-- 
2.7.4

